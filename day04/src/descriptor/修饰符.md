描述一个类

    修饰符 class 类名 {
        属性      权限 特征 类型 名字
        方法      权限 特征 返回值 名字 参数 异常 执行体
        构造方法   权限 名字 参数 异常 执行体
        程序块     执行体
    }
    
### 修饰符

#### 权限修饰符
1. public（公共的）  本类  同包 子类 当前项目中任意类的位置只要有对象都可以访问
2. protected（受保护的） 本类   同包 子类（通过子类对象在子类范围内部访问）
3. 默认不写（默认的）    本类  同包
4. private（私有的） 本类

#### 特征修饰符
1. final（最终的，不可更改的）
2. static（静态的）
3. abstract（抽象的）
4. native（本地的）
*5. transient（短暂的 瞬时的）--- > 序列化
*6. synchronized（同步的）--- > 线程相关的知识
*7. volatile（不稳定的） --- > 保护属性或方法的线程安全
---

#### 权限修饰符

1. 能修饰什么、范围如何？
    1. 类：只有两个可以用（public 默认不写）
    2. 权限修饰符用来修饰


> Java类和类之间的关系\
> 继承 关联 依赖


> Java面向对象的四个特征\
> 继承 封装 多态 抽象
    
>封装：将一些数据或执行过程 进行一个包装\
    方法本身就算是封装 封装了执行过程 保护过程的安全 隐藏了执行细节 增强复用性\
    好的方法和属性 --->  类（需要外部调用-->public）\
    对属性本身的封装：\
        1. 属性私有（封装在类中private）\
        2. 提供操作属性存取的方式（public）\
    以后强烈建议大家属性不要公有的 --> 非常不安全\
    既然以后大家都这样操作属性 属性及其操作属性的方法都有其命名的规约
    
`age ----> setAge getAge`

### 特征修饰符
1. 可以修饰什么？
2. 修饰以后有什么特点

#### final 最终的 不可更改的
1. 修饰变量
    1. 如果在定义变量时没有赋初始值 -> 给变量一次赋值的机会（因为变量在栈内存空间内 没有默认值 如果不给机会 就没法用啦）
    2. 一旦变量被存储了一个值 若用final修饰 则变成一个常量
    3. 基本类型：则变量的值不让更改 -- 常量
    4. 引用类型：则变量内的地址引用不让更改 -- 对象唯一
2. 修饰属性
    1. 全局变量 存储在堆内存的对象空间内的一个空间
    2. 属性如何没有赋值 有默认值的存在，所以用final修饰后，必须赋初值，否则编译报错
    3. 特点与修饰变量一致
3. 修饰方法
    1. 方法是最终的方法 不可更改 -> final修饰的方法 不可以被子类重写（覆盖）
4. 修饰类本身
    1. 类是最终的 不可以更改 -> （太监类 无后）此类不可以被其他子类继承
    2. 通常都是一些定义好的工具类



#### static 静态的
1. 修饰属性 、 方法 、 块 、 类（内部类 匿名内部类）
2. 特点：
    1. 静态元素在类加载时就初始化了，创建的非常早
    2. 静态元素存储在静态元素区中，每一个类有一个自己的区域，与别的类不冲突
    3. 静态元素只加载一次（只有一份）全部类对象及类本身共享
    4. 由于静态元素区加载的时候，有可能没有创建对象，可以通过类名字直接访问
    5. 可以理解为静态元素不属于任何一个对象，属于类的。
    6. 内存管理： 占内存创建开始用完及回收 堆内存通过GC回收 静态元素区GC无法管理 可以粗暴的认为常驻内存。
    7. 非静态成员（堆内存对象里）中可以访问静态成员（静态区）
    8. 静态成员中可以访问静态成员
    9. 静态成员中不可以访问非静态成员
    10. 静态元素中不可以出现this或super关键字（静态元素属于类）


> GC: Garbage Collection 垃圾回收器


#### abstract 抽象类 -- （不具体，没有具体的执行 只是个概念）
    修饰类 修饰方法
interface接口-- 结构 class

1. 修饰 类
2. 修饰 方法

用abstract修饰符修饰的方法 只有方法的结构 没有方法的执行体 叫做抽象方法
当然注意：用native修饰的方法虽然也没有方法体 但是不是抽象方法 只是执行的过程是其他语言写的 看不见

修饰类
用abstract修饰符修饰的类 叫做抽象类

抽象类中必须有冲向方法么？ no
抽象方法必须放在抽象类中么？ 也可以放在接口中。


什么叫抽象类 抽象类的特点：
1. 类里面有什么 成员
> 可以含有一般的属性、方法 private static final 普通块 静态块 构造方法（包括重载）
> 抽象类中是允许含有抽象方法（只有方法结构 没有方法执行体）
2. 类如何使用 创建对象
> 1. 抽象类含有构造方法 但是我们不能通过调用构造方法直接创建对象
> 2. 抽象类只能通过子类继承来做事
3. 类和类的关系
> 抽象类 --- 直接单继承 --- 抽象类   可以
> 抽象类 --- 直接单继承 --- 具体类   可以（写法可以，但用法上通常不会出现）
> 具体类 --- 直接单继承 --- 抽象类   不可以（将父类的抽象方法具体化 或让子类也变成抽象类）ok

4. 接口可以理解为是抽象类到极致 -> 还是一个类的结构 不能用class修饰 改用interface修饰

5. 什么是接口
 接口也是一个类的结构 只不过 用 interface 修饰 替换原有的 class
 
1. 成员：
    属性： 只能含有公有的静态的常量 public static final
    方法： 只能含有公有的抽象的方法（1.8 default 修饰具体方法）
    块： 不能含有块（块本身就是具体的，接口中不让有具体的）
    构造方法：不能含有构造方法
2. 如何使用：
    不能创建对象
    只能通过子类多继承（implements)来做事
    public class A implements B,C,D{}
3. 与别的类结构关系
    接口不能继承别的类   最抽象
    抽象类---直接多实现---接口   可以
    具体类---直接多实现---接口   不可以（必须将接口中的抽象方法全部具体化 或者 自己变成抽象类）
    接口---多继承---接口        可以直接多实现


#### native 本地的
Java源码中看到native就已经再也看不见后续代码
后续会调用其他的语言C/C++/汇编 执行内存的操作




# 程序设计的问题
1. 可读性 名字 缩进 注释
2. 健壮性 判断严谨
3. 优化 结构 性能 内存
4. 复用性 方法类
5. 可扩展性 抽象 接口 面向配置文件


































